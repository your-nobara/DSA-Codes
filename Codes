PRACTICAL NO :- 01 
Consider telephone book database of N clients. Make use of a hash table implementation
to quickly look up client‘s telephone number. Make use of two collision handling
techniques and compare them using number of comparisons required to find a set of
telephone numbers.

#PROGRAM
# Hash Table using Linear Probing

class LinearProbingHashTable:
    def __init__(self, size):
        # Initialize empty table of given size
        self.size = size
        self.table = [None] * size

    def insert(self, key, name):
        # Insert (key, name) pair using linear probing
        idx = key % self.size  # Hash function
        while self.table[idx] is not None:
            # If collision happens, move to next index
            idx = (idx + 1) % self.size
        self.table[idx] = (key, name)

    def search(self, key):
        # Search key and count number of comparisons
        comparisons = 0
        idx = key % self.size
        start = idx
        while self.table[idx] is not None:
            comparisons += 1
            if self.table[idx][0] == key:
                return self.table[idx][1], comparisons  # Return name and comparisons
            idx = (idx + 1) % self.size
            if idx == start:
                break  # If we come back to starting point, stop
        return None, comparisons

    def display(self):
        # Display the complete table
        for i in range(self.size):
            if self.table[i]:
                print(f"Index {i}: {self.table[i][0]} -> {self.table[i][1]}")
            else:
                print(f"Index {i}: Empty")

# Hash Table using Chaining

class Node:
    def __init__(self, key, name):
        # Node for linked list in chaining
        self.key = key
        self.name = name
        self.next = None

class ChainingHashTable:
    def __init__(self, size):
        # Initialize empty table
        self.size = size
        self.table = [None] * size

    def insert(self, key, name):
        # Insert (key, name) using chaining
        idx = key % self.size  # Hash function
        new_node = Node(key, name)
        if self.table[idx] is None:
            self.table[idx] = new_node
        else:
            temp = self.table[idx]
            # Traverse to end of linked list and insert
            while temp.next:
                temp = temp.next
            temp.next = new_node

    def search(self, key):
        # Search key and count number of comparisons
        comparisons = 0
        idx = key % self.size
        temp = self.table[idx]
        while temp:
            comparisons += 1
            if temp.key == key:
                return temp.name, comparisons  # Return name and comparisons
            temp = temp.next
        return None, comparisons

    def display(self):
        # Display full hash table
        for i in range(self.size):
            print(f"Index {i}:", end=" ")
            temp = self.table[i]
            if not temp:
                print("Empty")
            else:
                while temp:
                    print(f"({temp.key} -> {temp.name})", end=" -> ")
                    temp = temp.next
                print("None")

# Main Program

def main():
    n = int(input("Enter number of clients: "))
    lp = LinearProbingHashTable(10)  # Hash table for linear probing
    ch = ChainingHashTable(10)       # Hash table for chaining

    print("\nEnter client details (Phone Number and Name):")
    for _ in range(n):
        phone = int(input("Phone Number: "))
        name = input("Name: ")
        lp.insert(phone, name)  # Insert into linear probing table
        ch.insert(phone, name)  # Insert into chaining table

    print("\nLinear Probing Telephone Book:")
    lp.display()

    print("\nChaining Telephone Book:")
    ch.display()

    # Search and compare
    key = int(input("\nEnter phone number to search: "))

    res_lp, comp_lp = lp.search(key)
    res_ch, comp_ch = ch.search(key)

    if res_lp:
        print(f"\n[Linear Probing] Found {res_lp} with {comp_lp} comparisons.")
    else:
        print("\n[Linear Probing] Phone number not found.")

    if res_ch:
        print(f"[Chaining] Found {res_ch} with {comp_ch} comparisons.")
    else:
        print("[Chaining] Phone number not found.")

    print("\nComparison:")
    if comp_lp < comp_ch:
        print("Linear Probing is faster for this search.")
    elif comp_ch < comp_lp:
        print("Chaining is faster for this search.")
    else:
        print("Both methods took same number of comparisons.")

if __name__ == "__main__":
    main()

PRACTICAL NO :- 02
To create ADT that implement the "set" concept.
a. Add (newElement) -Place a value into the set
b. Remove (element) Remove the value
c. Contains (element) Return true if element is in collection
d. Size () Return number of values in collection Iterator () Return an iterator used to loop
over collection
e. Intersection of two sets
f. Union of two sets
g. Difference between two sets
h.Subset 

#PROGRAM
class Set:
    def __init__(self):  # Fixed constructor
        self.elements = []
        
    def add(self, item): 
        if item not in self.elements: 
            self.elements.append(item)
    
    def remove(self, item): 
        if item in self.elements: 
            self.elements.remove(item)
    
    def contains(self, item): 
        return item in self.elements
    
    def size(self): 
        return len(self.elements)
    
    def iterator(self): 
        return iter(self.elements)
    
    def intersection(self, other): 
        return Set.from_list([e for e in self.elements if other.contains(e)])
    
    def union(self, other):
        result = Set()  
        result.elements = self.elements.copy()
        for e in other.elements: 
            result.add(e)
        return result
    
    def difference(self, other): 
        return Set.from_list([e for e in self.elements if not other.contains(e)])
    
    def subset(self, other): 
        return all(other.contains(e) for e in self.elements)
    
    @staticmethod
    def from_list(lst):
        s = Set()
        for item in lst: 
            s.add(item)
        return s

def create_set(name):
    s = Set()
    for _ in range(int(input(f"Enter number of elements for {name}: "))):
        element = input("Enter element: ")  # Ensure to enter as string or make it type-specific if needed
        s.add(element)
    return s

# Create sets
s1, s2 = create_set("Set 1"), create_set("Set 2")

# Output
print("Set 1:", list(s1.iterator()))
print("Set 2:", list(s2.iterator()))
print("Intersection:", list(s1.intersection(s2).iterator()))
print("Union:", list(s1.union(s2).iterator()))
print("Difference (Set1 - Set2):", list(s1.difference(s2).iterator()))
print("Set1 is subset of Set2:", s1.subset(s2))


PRACTICAL NO :- 03
A book consists of chapters, chapters consist of sections and sections consist of
subsections. Construct a tree and print the nodes. Find the time and space requirements
of your method. 

#PROGRAM
#include <iostream>
#include <vector>
#include <chrono>
using namespace std;
using namespace chrono;

// Structure to represent a node in the tree
struct Node {
    string name;
    vector<Node*> children;
    Node(string nodeName) : name(nodeName) {}
};

// Function to print the tree structure in a simplified format
void printTree(Node* root, int& nodeCount) {
    if (!root) return;
    
    cout << root->name << endl;
    nodeCount++;
    
    for (Node* child : root->children) {
        printTree(child, nodeCount);
    }
}

// Function to count the total number of nodes in the tree
int countNodes(Node* root) {
    if (!root) return 0;
    int count = 1;
    for (Node* child : root->children) {
        count += countNodes(child);
    }
    return count;
}

// Function to measure the time taken for an operation
template <typename Func, typename... Args>
double measureTime(Func&& func, Args&&... args) {
    auto start = high_resolution_clock::now();
    func(std::forward<Args>(args)...);
    auto end = high_resolution_clock::now();
    duration<double> duration = end - start;
    return duration.count();
}

int main() {
    // Input the book name
    cout << "Enter the name of the book: ";
    string bookName;
    getline(cin, bookName);
    
    // Create the root node for the book
    Node* book = new Node("Book: " + bookName);
    
    // Input the number of chapters
    int numChapters;
    cout << "Enter the number of chapters: ";
    cin >> numChapters;
    
    for (int i = 1; i <= numChapters; i++) {
        // Input chapter name
        cout << "Enter the name of Chapter " << i << ": ";
        cin.ignore();
        string chapterName;
        getline(cin, chapterName);
        
        // Create a chapter node
        Node* chapter = new Node("Chapter: " + chapterName);
        book->children.push_back(chapter);
        
        // Input the number of sections in the chapter
        int numSections;
        cout << "Enter the number of sections in " << chapterName << ": ";
        cin >> numSections;
        
        for (int j = 1; j <= numSections; j++) {
            // Input section name
            cout << "Enter the name of Section " << j << ": ";
            cin.ignore();
            string sectionName;
            getline(cin, sectionName);
            
            // Create a section node
            Node* section = new Node("Section: " + sectionName);
            chapter->children.push_back(section);
        }
    }
    
    // Measure the time taken to print the tree structure
    int nodeCount = 0;
    double printTime = measureTime([&]() {
        cout << "\nBook: " << bookName << endl;
        cout << "Chapters:" << endl;
        for (int i = 0; i < book->children.size(); i++) {
            cout << i + 1 << ". " << book->children[i]->name.substr(9) << endl;
        }
        
        for (int i = 0; i < book->children.size(); i++) {
            cout << "\nChapter " << i + 1 << " - " << book->children[i]->name.substr(9) << " has " << book->children[i]->children.size() << " sections:" << endl;
            for (int j = 0; j < book->children[i]->children.size(); j++) {
                cout << j + 1 << ". " << book->children[i]->children[j]->name.substr(9) << endl;
            }
        }
        
        printTree(book, nodeCount);
    });
    
    // Measure the time taken to count the total number of nodes
    double countTime = measureTime([&]() {
        int totalNodes = countNodes(book);
        cout << "\nTotal number of nodes: " << totalNodes << endl;
    });
    
    // Print the time taken for each operation
    cout << "\nTime taken to print the tree: " << printTime << " seconds" << endl;
    cout << "Time taken to count nodes: " << countTime << " seconds" << endl;
    
    // Time and space complexity
    cout << "\nTime Complexity: O(n), Space Complexity: O(n)" << endl;
    
    // Delete the tree to free memory
    delete book;
    
    return 0;
}


PRACTICAL NO :- 04
Beginning with an empty binary search tree, Construct binary search tree by inserting the
values in the order given. After constructing a binary tree -
i. Insert new node
ii. Find number of nodes in longest path from root
iii. Minimum data value found in the tree
iv. Change a tree so that the roles of the left and right pointers are swapped at every node
v. Search a value

#PROGRAM
#include <bits/stdc++.h>
using namespace std;

// Structure for a node in the binary search tree
struct Node {
    int data;
    Node* left;
    Node* right;

    // Constructor to initialize a new node
    Node(int val) : data(val), left(NULL), right(NULL) {}
};

// Function to insert a node into the binary search tree
Node* insert(Node* root, int val) {
    if (!root) return new Node(val);
    if (val < root->data) root->left = insert(root->left, val); // Insert in left subtree
    else root->right = insert(root->right, val); // Insert in right subtree
    return root;
}

// Preorder traversal of the binary search tree
void preorder(Node* root) {
    if (root) {
        cout << root->data << " ";
        preorder(root->left);
        preorder(root->right);
    }
}

// Function to find the height (longest path) of the tree
int height(Node* root) {
    if (!root) return -1; // Returns -1 for an empty tree, since height is the number of edges
    return 1 + max(height(root->left), height(root->right)); // Return height of the tree
}

// Function to find the minimum value in the binary search tree
int minimum(Node* root) {
    return root->left ? minimum(root->left) : root->data;
}

// Function to search for a value in the tree
bool search(Node* root, int key) {
    if (!root) return false; // If root is null, return false
    if (root->data == key) return true; // If the current node is the key, return true
    if (key < root->data) // Search left if key is smaller than root data
        return search(root->left, key);
    else // Otherwise search right if key is greater than root data
        return search(root->right, key);
}

// Function to mirror the tree (swap left and right pointers)
void mirror(Node* root) {
    if (root) {
        swap(root->left, root->right); // Swap left and right children
        mirror(root->left);
        mirror(root->right);
    }
}

int main() {
    Node* root = NULL;
    int n;

    // Input the number of nodes to insert
    cout << "Enter number of nodes: ";
    cin >> n;

    // Insert the nodes into the binary search tree
    for (int i = 0; i < n; ++i) {
        int val;
        cout << "Enter node " << i + 1 << ": ";
        cin >> val;
        root = insert(root, val);
    }

    // Preorder traversal of the tree
    cout << "BST Preorder Traversal: ";
    preorder(root);
    cout << endl;

    // Height of the tree (longest path)
    cout << "Height (Longest Path): " << height(root) << endl;

    // Minimum value in the tree
    cout << "Minimum value: " << minimum(root) << endl;

    // Mirror the tree and show the result
    mirror(root);
    cout << "Mirrored BST Preorder Traversal: ";
    preorder(root);
    cout << endl;

    // Search for a value
    int key;
    cout << "Enter key to search: ";
    cin >> key;
    if (search(root, key))
        cout << "Key " << key << " is present in the BST!" << endl;
    else
        cout << "Key " << key << " is not present in the BST!" << endl;

    return 0;
}


PRACTICAL NO :- 05
Convert given binary tree into threaded binary tree. Analyze time and space complexity
of the algorithm. 

#PROGRAM
#include <bits/stdc++.h>
using namespace std;
using namespace chrono;

struct Node {
    int data;
    Node *left, *right;
    bool isThreaded;

    Node(int val) : data(val), left(nullptr), right(nullptr), isThreaded(false) {}
};

int nodeCount = 0;

void createThreaded(Node* root, Node* &prev) {
    if (!root) return;
    createThreaded(root->left, prev);

    if (prev && prev->right == nullptr) {
        prev->right = root;
        prev->isThreaded = true;
    }
    prev = root;
    createThreaded(root->right, prev);
}

Node* leftmost(Node* root) {
    while (root && root->left) root = root->left;
    return root;
}

void inorderTraversal(Node* root) {
    for (Node* current = leftmost(root); current != nullptr; current = (current->isThreaded ? current->right : leftmost(current->right))) {
        cout << current->data << " ";
    }
}

Node* insert(Node* root, int key) {
    if (!root) { nodeCount++; return new Node(key); }
    root = (key < root->data) ? insert(root->left, key) : insert(root->right, key);
    return root;
}

int main() {
    auto start = high_resolution_clock::now();
    Node* root = nullptr;
    for (int key : {10, 5, 20, 3, 7, 15, 25}) root = insert(root, key);

    Node* prev = nullptr;
    createThreaded(root, prev);

    auto end = high_resolution_clock::now();
    cout << "Inorder Traversal using Threaded Binary Tree: ";
    inorderTraversal(root);
    cout << "\nExecution Time: " << duration_cast<microseconds>(end - start).count() << " microseconds\n";

    int spaceUsed = nodeCount * sizeof(Node);
    cout << "Total Nodes Created: " << nodeCount << "\nApproximate Space Used: " << spaceUsed << " bytes\n";

    return 0;
}

PRACTICAL NO :- 06
There are flight paths between cities. If there is a flight between city A and city B then there is an edge between the cities.
The cost of the edge can be the time that flight take to reach city B from A, or the amount of fuel used for the journey. 
Represent this as a graph.The node can be represented by airport name or name of the city.
Use adjacency list representation of the graph or use adjacency matrix representation of the graph. 
Check whether the graph is connected or not. Justify the storage representation used.

#PROGRAM
#include <iostream>
#include <queue>
using namespace std;

int adj_mat[50][50] = {0};  // Adjacency matrix for graph representation
int visited[50] = {0};       // Visited array for DFS and BFS

// DFS Function
void dfs(int s, int n, string arr[]) {
    visited[s] = 1;
    cout << arr[s] << " ";
    for (int i = 0; i < n; i++) {
        if (adj_mat[s][i] && !visited[i]) dfs(i, n, arr);
    }
}

// BFS Function
void bfs(int s, int n, string arr[]) {
    bool visited[n] = {0};  // Reset visited for BFS
    queue<int> q;
    visited[s] = 1;
    q.push(s);
    cout << arr[s] << " ";
    while (!q.empty()) {
        int v = q.front(); q.pop();
        for (int i = 0; i < n; i++) {
            if (adj_mat[v][i] && !visited[i]) {
                cout << arr[i] << " ";
                visited[i] = 1;
                q.push(i);
            }
        }
    }
}

int main() {
    int n, u;
    cout << "Enter number of cities: ";
    cin >> n;
    
    string cities[n];
    for (int i = 0; i < n; i++) {
        cout << "Enter city #" << i + 1 << " (Airport Code): ";
        cin >> cities[i];
    }

    // Input distances between cities
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            cout << "Enter distance (time/fuel) between " << cities[i] << " and " << cities[j] << ": ";
            cin >> adj_mat[i][j];
            adj_mat[j][i] = adj_mat[i][j];  // Since the graph is undirected
        }
    }

    // Display adjacency matrix
    cout << "\n\t";
    for (int i = 0; i < n; i++) cout << cities[i] << "\t";
    cout << "\n";
    for (int i = 0; i < n; i++) {
        cout << cities[i];
        for (int j = 0; j < n; j++) cout << "\t" << adj_mat[i][j] << "\t";
        cout << endl;
    }

    // Input starting city for traversal
    cout << "Enter starting city (index 0 to " << n - 1 << "): ";
    cin >> u;

    // Perform DFS and BFS
    cout << "DFS: ";
    fill(begin(visited), end(visited), 0);  // Reset visited array
    dfs(u, n, cities);
    cout << "\nBFS: ";
    bfs(u, n, cities);
    cout << endl;

    return 0;
}

PRACTICAL NO :- 07
You have a business with several offices; you want to lease phone lines to connect them
up with each other; and the phone company charges different amounts of money to
connect different pairs of cities. You want a set of lines that connects all your offices with
a minimum total cost.

#PROGRAM
#include <iostream>
#include <climits>
using namespace std;

#define INF 999

class PrimMST {
    int graph[20][20], V;

public:
    void input();
    void display();
    void findMST();
};

void PrimMST::input() {
    cout << "Enter number of offices: ";
    cin >> V;

    // Initialize graph with INF
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            graph[i][j] = INF;

    int E;
    cout << "Enter number of connections: ";
    cin >> E;

    cout << "Enter edges (office1 office2 cost):\n";
    for (int i = 0; i < E; i++) {
        int u, v, cost;
        cin >> u >> v >> cost;
        graph[u-1][v-1] = graph[v-1][u-1] = cost;
    }
}

void PrimMST::display() {
    cout << "\nAdjacency Matrix:\n   ";
    for (int i = 0; i < V; i++) cout << i+1 << "   ";
    cout << endl;

    for (int i = 0; i < V; i++) {
        cout << i+1 << " ";
        for (int j = 0; j < V; j++)
            cout << (graph[i][j] == INF ? "INF" : to_string(graph[i][j])) << " ";
        cout << endl;
    }
}

void PrimMST::findMST() {
    int parent[V], key[V];
    bool visited[V] = {false};

    for (int i = 0; i < V; i++) key[i] = INF;
    key[0] = 0;
    parent[0] = -1;

    for (int count = 0; count < V - 1; count++) {
        int minKey = INF, u;

        for (int i = 0; i < V; i++)
            if (!visited[i] && key[i] < minKey)
                minKey = key[i], u = i;

        visited[u] = true;

        for (int v = 0; v < V; v++) {
            if (graph[u][v] != INF && !visited[v] && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    cout << "\nMinimum Spanning Tree (MST) connections:\n";
    int totalCost = 0;
    for (int i = 1; i < V; i++) {
        cout << "Office " << parent[i]+1 << " -> Office " << i+1
             << " with cost: " << graph[i][parent[i]] << endl;
        totalCost += graph[i][parent[i]];
    }
    cout << "Total minimum cost to connect all offices: " << totalCost << endl;
}

int main() {
    PrimMST p;
    int choice;
    do {
        cout << "\n======= PRIM'S ALGORITHM =======\n";
        cout << "1. Input Graph\n2. Display Graph\n3. Find MST\n4. Exit\nEnter choice: ";
        cin >> choice;
        switch (choice) {
            case 1: p.input(); break;
            case 2: p.display(); break;
            case 3: p.findMST(); break;
            case 4: cout << "Exiting...\n"; break;
            default: cout << "Invalid choice!\n";
        }
    } while (choice != 4);

    return 0;
}

PRACTICAL NO :08
Given sequence k = k1 <k2 < … <kn of n sorted keys, with a search probability pi for each
key ki . Build the Binary search tree that has the least search cost given the access
probability for each key? 

#PROGRAM
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

class OBST {
    vector<int> keys, freq;
    vector<vector<int>> cost, root;
    int n;

public:
    void getInput();
    void buildOBST();
    void printPreorder(int, int);
};

void OBST::getInput() {
    cout << "\nEnter number of keys: ";
    cin >> n;

    keys.resize(n);
    freq.resize(n);
    cost.assign(n, vector<int>(n));
    root.assign(n, vector<int>(n));

    cout << "\nEnter keys: ";
    for (auto &k : keys) cin >> k;
    cout << "\nEnter corresponding frequencies: ";
    for (auto &f : freq) cin >> f;
}

void OBST::buildOBST() {
    vector<vector<int>> sum(n, vector<int>(n));

    for (int i = 0; i < n; i++) {
        cost[i][i] = freq[i];
        root[i][i] = i;
        sum[i][i] = freq[i];
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            sum[i][j] = sum[i][j-1] + freq[j];
            cost[i][j] = INT_MAX;

            for (int r = i; r <= j; r++) {
                int total = (r > i ? cost[i][r-1] : 0) + (r < j ? cost[r+1][j] : 0) + sum[i][j];
                if (total < cost[i][j]) {
                    cost[i][j] = total;
                    root[i][j] = r;
                }
            }
        }
    }

    cout << "\nOptimal BST Cost: " << cost[0][n-1] << endl;
    cout << "\nPreorder Traversal of OBST: ";
    printPreorder(0, n-1);
    cout << endl;
}

void OBST::printPreorder(int i, int j) {
    if (i > j) return;
    int r = root[i][j];
    cout << keys[r] << " ";
    printPreorder(i, r-1);
    printPreorder(r+1, j);
}

int main() {
    OBST tree;
    cout << "\n-----*** Optimal BST Construction ***-----";
    tree.getInput();
    tree.buildOBST();
    return 0;
}

PRACTICAL NO :- 09
A Dictionary stores keywords & its meanings. Provide facility for adding new keywords,
deleting keywords, updating values of any entry. Provide facility to display whole data
sorted in ascending/ Descending order. Also find how many maximum comparisons may
require for finding any keyword. Use Height balance tree and find the complexity for
finding a keyword 

#PROGRAM
#include <iostream>
#include <map>
#include <string>
using namespace std;

class Dictionary {
    map<string, string> dict;

public:
    void insert(const string &key, const string &meaning) {
        dict[key] = meaning;
        cout << "Keyword '" << key << "' added successfully.\n";
    }

    void remove(const string &key) {
        cout << (dict.erase(key) ? "Keyword '" + key + "' deleted successfully.\n"
                                 : "Keyword '" + key + "' not found.\n");
    }

    void display(bool ascending = true) {
        if (dict.empty()) {
            cout << "Dictionary is empty.\n";
            return;
        }
        cout << "\nDictionary (" << (ascending ? "Ascending" : "Descending") << " Order):\n";
        if (ascending)
            for (const auto &entry : dict)
                cout << entry.first << " : " << entry.second << endl;
        else
            for (auto it = dict.rbegin(); it != dict.rend(); ++it)
                cout << it->first << " : " << it->second << endl;
    }

    void search(const string &key) {
        auto it = dict.find(key);
        cout << (it != dict.end() ? "Keyword found: " + it->first + " -> " + it->second + "\n"
                                  : "Keyword '" + key + "' not found.\n");
    }
};

int main() {
    Dictionary d;
    int choice;
    string key, meaning;
    const string menu[] = {
        "1. Insert Keyword", "2. Delete Keyword",
        "3. Display Dictionary (Ascending)", "4. Display Dictionary (Descending)",
        "5. Search Keyword", "6. Exit"
    };

    do {
        cout << "\n===== DICTIONARY MENU =====\n";
        for (const auto &item : menu)
            cout << item << endl;
        cout << "Enter your choice: ";
        cin >> choice;

        switch (choice) {
            case 1:
                cout << "Enter keyword: ";
                cin >> key;
                cout << "Enter meaning: ";
                cin.ignore();
                getline(cin, meaning);
                d.insert(key, meaning);
                break;
            case 2:
                cout << "Enter keyword to delete: ";
                cin >> key;
                d.remove(key);
                break;
            case 3:
                d.display(true);
                break;
            case 4:
                d.display(false);
                break;
            case 5:
                cout << "Enter keyword to search: ";
                cin >> key;
                d.search(key);
                break;
            case 6:
                cout << "Exiting program...\n";
                break;
            default:
                cout << "Invalid choice! Please enter a valid option.\n";
        }
    } while (choice != 6);

    return 0;
}

PRACTICAL NO :- 10
Read the marks obtained by students of second year in an online examination of
particular subject. Find out maximum and minimum marks obtained in that subject. Use
heap data structure. Analyze the algorithm.

#PROGRAM
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int n;
    cout << "Enter the number of students: ";
    cin >> n;

    if (n <= 0) {
        cout << "Invalid number of students!" << endl;
        return 1;
    }

    vector<int> marks(n);
    cout << "Enter the marks of students: ";
    for (int &mark : marks) cin >> mark;

    priority_queue<int> maxHeap(marks.begin(), marks.end());
    priority_queue<int, vector<int>, greater<int>> minHeap(marks.begin(), marks.end());

    cout << "\n===== Results =====\n";
    cout << "Maximum marks obtained: " << maxHeap.top() << endl;
    cout << "Minimum marks obtained: " << minHeap.top() << endl;

    return 0;
}

PRACTICAL NO :- 11
Department maintains a student information. The file contains roll number, name,
division and address. Allow user to add, delete information of student. Display
information of particular employee. If record of student does not exist an appropriate
message is displayed. If it is, then the system displays the student details. Use sequential
file to main the data

#PROGRAM
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
using namespace std;

struct Student { int roll; string name, div, addr; };

void addStudent() {
    ofstream f("students.txt", ios::app);
    if (!f) { cout << "Error opening file!\n"; return; }
    Student s;
    cout << "Enter Roll Number: "; cin >> s.roll; cin.ignore();
    cout << "Enter Name: "; getline(cin, s.name);
    cout << "Enter Division: "; getline(cin, s.div);
    cout << "Enter Address: "; getline(cin, s.addr);
    f << s.roll << ',' << s.name << ',' << s.div << ',' << s.addr << '\n';
    cout << "Student added successfully!\n";
}

void displayAllStudents() {
    ifstream f("students.txt");
    if (!f) { cout << "No records found!\n"; return; }
    string l; bool found = false;
    cout << "\nStudent Records:\n-------------------------------------------\n";
    cout << "Roll No | Name | Division | Address\n-------------------------------------------\n";
    while (getline(f, l)) {
        stringstream ss(l); Student s; string r;
        getline(ss, r, ','); getline(ss, s.name, ',');
        getline(ss, s.div, ','); getline(ss, s.addr, ',');
        cout << stoi(r) << " | " << s.name << " | " << s.div << " | " << s.addr << endl;
        found = true;
    }
    if (!found) cout << "No student records found!\n";
}

void displayStudent(int roll) {
    ifstream f("students.txt");
    if (!f) { cout << "No records found!\n"; return; }
    string l; bool found = false;
    while (getline(f, l)) {
        stringstream ss(l); Student s; string r;
        getline(ss, r, ','); getline(ss, s.name, ',');
        getline(ss, s.div, ','); getline(ss, s.addr, ',');
        if (stoi(r) == roll) {
            cout << "\nStudent Found:\nRoll Number: " << r << "\nName: " << s.name
                 << "\nDivision: " << s.div << "\nAddress: " << s.addr << endl;
            found = true; break;
        }
    }
    if (!found) cout << "Student record not found!\n";
}

void deleteStudent(int roll) {
    ifstream f("students.txt");
    if (!f) { cout << "No records found!\n"; return; }
    ofstream t("temp.txt");
    string l; bool found = false;
    while (getline(f, l)) {
        stringstream ss(l); Student s; string r;
        getline(ss, r, ','); getline(ss, s.name, ',');
        getline(ss, s.div, ','); getline(ss, s.addr, ',');
        if (stoi(r) == roll) { found = true; continue; }
        t << l << '\n';
    }
    f.close(); t.close();
    remove("students.txt"); rename("temp.txt", "students.txt");
    cout << (found ? "Student record deleted successfully!\n" : "Student record not found!\n");
}

int main() {
    int ch, roll;
    do {
        cout << "\nStudent Information System\n1. Add Student\n2. Display All Students\n";
        cout << "3. Display Student by Roll Number\n4. Delete Student\n5. Exit\nEnter your choice: ";
        cin >> ch;
        switch (ch) {
            case 1: addStudent(); break;
            case 2: displayAllStudents(); break;
            case 3: cout << "Enter Roll Number to Search: "; cin >> roll; displayStudent(roll); break;
            case 4: cout << "Enter Roll Number to Delete: "; cin >> roll; deleteStudent(roll); break;
            case 5: cout << "Exiting...\n"; break;
            default: cout << "Invalid choice! Please try again.\n";
        }
    } while (ch != 5);
}

PRACTICAL NO :- 12
Company maintains employee information as employee ID, name, designation and salary.
Allow user to add, delete information of employee. Display information of particular
employee. If employee does not exist an appropriate message is displayed. If it is, then
the system displays the employee details. Use index sequential file to maintain the data. 

#PROGRAM
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
using namespace std;

struct Employee { int id; string name, desig; float sal; };

void addEmployee() {
    ofstream f("employees.txt", ios::app);
    if (!f) { cout << "Error opening file!\n"; return; }
    Employee e;
    cout << "Enter Employee ID: "; cin >> e.id; cin.ignore();
    cout << "Enter Name: "; getline(cin, e.name);
    cout << "Enter Designation: "; getline(cin, e.desig);
    cout << "Enter Salary: "; cin >> e.sal;
    f << e.id << ',' << e.name << ',' << e.desig << ',' << e.sal << '\n';
    cout << "Employee added successfully!\n";
}

void searchEmployee(int id) {
    ifstream f("employees.txt");
    if (!f) { cout << "No records found!\n"; return; }
    string l; bool found = false;
    while (getline(f, l)) {
        stringstream ss(l); Employee e; string idStr;
        getline(ss, idStr, ','); getline(ss, e.name, ','); getline(ss, e.desig, ','); ss >> e.sal;
        if (stoi(idStr) == id) {
            cout << "\nEmployee Found:\nID: " << idStr << "\nName: " << e.name
                 << "\nDesignation: " << e.desig << "\nSalary: " << e.sal << endl;
            found = true; break;
        }
    }
    if (!found) cout << "Employee record not found!\n";
}

void deleteEmployee(int id) {
    ifstream f("employees.txt");
    if (!f) { cout << "No records found!\n"; return; }
    ofstream t("temp.txt");
    string l; bool found = false;
    while (getline(f, l)) {
        stringstream ss(l); Employee e; string idStr;
        getline(ss, idStr, ','); getline(ss, e.name, ','); getline(ss, e.desig, ','); ss >> e.sal;
        if (stoi(idStr) == id) { found = true; continue; }
        t << l << '\n';
    }
    f.close(); t.close();
    remove("employees.txt"); rename("temp.txt", "employees.txt");
    cout << (found ? "Employee record deleted successfully!\n" : "Employee record not found!\n");
}

int main() {
    int ch, id;
    do {
        cout << "\nCompany Employee Management System\n1. Add Employee\n2. Search Employee\n";
        cout << "3. Delete Employee\n4. Exit\nEnter your choice: ";
        cin >> ch;
        switch (ch) {
            case 1: addEmployee(); break;
            case 2: cout << "Enter Employee ID to Search: "; cin >> id; searchEmployee(id); break;
            case 3: cout << "Enter Employee ID to Delete: "; cin >> id; deleteEmployee(id); break;
            case 4: cout << "Exiting...\n"; break;
            default: cout << "Invalid choice! Please try again.\n";
        }
    } while (ch != 4);
}
